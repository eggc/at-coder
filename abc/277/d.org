* 問題

最初に好きなカード X をおく

X or (X+1) mod M があれば次のカードをだせる。

最後に手札に残るカードが最小になるようにしよう。

例 M = 7 のとき

X = 5 ならば 6 % 7 = 6 なので 6 が出せる。
X = 6 ならば 7 % 7 = 0 なので 0 が出せる。
X = 0 ならば 1 % 7 = 1 なので 1 が出せる。

出せるカードが 2, 3, 4, ... と 循環していく感じ。
同じカードを出してもいい。

* 模範解答

k = tally.size とする。
ただし tally は昇順ソートしているものとする。

1 枚目に出す数を vi としたときの点数を si とする。
s0, s1, ... sk-1 を求めたい。下記の表を作る。

| 捨てるカード i |    0 |    1 |    2 | .. |
|----------------+------+------+------+----|
| スコア         | s[0] | s[1] | s[2] |    |

次に出せる数 X = (vi + 1) % M に注目する。

1. X = v((i+1) % k) でないなら tally の次の数を出せない。よって計算は終わり最終スコアは total_score - tally[vi] * vi。
2. X = v((i+1) % k) であるなら tally の次の数を出すことができる。この場合最終スコアは s[i+1] - tally[vi] * vi。

他を参照せずに計算できる 1 のケースを計算してから、残りを芋づる式に計算できる。

たとえば下のような構成になってたとする
M = 5 で A = [1,2,3,4]

このときの捨てるカードとスコアの計算をしてみる。
1 を捨てるとしたら X = 1+1 % 5 = 2 になるので次は 2 なので (2) のケースとして保留
2 を捨てるとしたら X = 3 になるので保留
...
4 を捨てるとしたら X = 5 になるがこれ以上計算不可能なので、ここは答えがすぐ求まる。
1+2+3+4 -4 = 6

10 を捨てるとしたら X = 1 になるので保留

| 捨てるカード |        1 |        2 |        3 | 4 |
|--------------+----------+----------+----------+---|
| スコア       | s[2] - 1 | S[3] - 2 | S[4] - 3 | 6 |

こうして計算してみると 1 を捨てれば全部捨てれることがわかる。

これが巡回してる場合無限ループになってしまうので最初に全部埋まっている場合は直ちに 0 点として脱出したほうが良い。

歯抜けが複数あるケースも考えてみよう。
M = 6, A = [1,2,4,5]

| 捨てるカード |       1 |  2 |        4 | 5 |
|--------------+---------+----+----------+---|
| スコア       | S[2] -1 | 10 | S[4] - 3 | 7 |

こんな感じで計算できる。
計算の順序は、それ自体で計算できるものを起点として一個ずつ後ろにカウントダウンしていくと確実になる。

* 失敗例を探す

3 11
0 1 10

これが失敗する。始点は 1 で OK。ただ終点がおかしいかも。

* 別な解き方

最初の数は自由に選べるので適当に大きな数を選んでから
その後をシミュレーションするというのがいいんじゃねえか。
X が 10^9 通りあるとしたら、それぞれに対してどういう最小値が出るのかというのを調べる。
たとえば

M = 6
1 2 3 4 5 6 7 20000

があったとして 20000 を最初に選択したとする。そしたら
20001 % 6 = 3 になるので 3, 4, 5, 6, 1, 2 を順番に出して終了。
これが歯抜けになってた場合

M = 6
1 2 3 4 6 7 20000 20001

こうだと 20000 の方を選んだほうが強い。
だから常に最大を選べばいいというわけではない。

M が小さいなら全ての X の場合のシミュレーションを予めだしといて

| X     |  1 |  2 | ... |
|-------+----+----+-----|
| score | 10 | 11 | ... |

みたいな感じで点数を出しとけば最初の数を選んだときと足し合わせて計算ができる。
ただ M は 10^9 もあるから表で持つわけじゃなくて関数とかで持てるほうがいい。
でも歯抜けの場合があるからやっぱり計算では厳しい。…ジレンマ。いや、よく考えたら
最大でも 20000 通りしかないからやっぱ計算したほうがいい気がする。
X の取りうるパターンは N から計算できるからいける。

で、X のときの解はソートして単調数列の和をとればいい。

* ダメな別な解き方

素直に探索するとしたらどんな感じなんだろう。
カードの値は最大で 10^9 種類ある。
カードの枚数は 20000 枚。

点数 k のもとで i 番目のカードを使ったときの残りの数の和を出してみるとか。
まぁそもそも出せないカードのほうが多いけどな。

たとえば 0枚提出の場合 A[0..N] の総和が答え。
1 枚提出の場合は A[0..N] から A[0], ... A[N] を引いたのが答え。
2 枚提出の場合は 上記のやつから選ばなかったやつを引いたのが答え。
3 枚…。
と調べていくことはできなくもない。

ただこれが全組み合わせの探索にほかならないから計算量が N! になる。

| スコア\出したカード | A[0]           | A[1] | ... |
|---------------------+----------------+------+-----|
| A[0..N]             | A[0..N] - A[0] |      |     |
| ?                   |                |      |     |
| ?                   |                |      |     |
| ?                   |                |      |     |

と計算することはできるかも。
出せないところは x をつけるとかでいいのかな。
表の最後まで埋めたら答えが出る。
うーん怪しいけどやってみる？　一応探索範囲は N * M かなぁ最大で。
しかし X という数によって出せるカードが変化するから、
表の中に X を組み込まなきゃいけなくてそれは難しいのではないか。

| スコア\X |           0 |           1 | ... |
|----------+-------------+-------------+-----|
| A[0..N]  | A[0..N] - 0 | A[0..N] - 1 |     |
| ?        |             |             |     |
| ?        |             |             |     |
| ?        |             |             |     |

こういう感じの表がいいのかな？　なんかおかしい気がする。

* ダメな解き方

最小値を探索する問題なので全探索するなら
どの順番でカードを出すのかという順列を作って、それを一個ずつ試せばいい。
でも順列の計算は N! になるのでまず不可能。


なので最適な戦略は +0 または +1 の増加数列で総和が最も大きいものを見つける。

それに対応できるような X を設定する最大のカードを選択する。

残ったカードが最小になる。

** 増加数列を見つけるなら
ソートして A[i..j] の総和が最も大きいものを選択すればいい。

** 数列が受け入れる X の候補を考える

たとえば M=6 で A[i..j] = 1000, 1001, 1002, 1003 だったとする。
このときは A[i..j] は絶対に出せないのでやりたいことはできない…。
詰まった。
