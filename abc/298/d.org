* 例

|  S | query |
|  1 |       |
|  1 |     3 |
| 12 |   1 2 |
| 2  |     2 |

3
3
1 2
3

クエリは 60000。
0 は追加されない。
* 考察

たぶん数字組み立てるのは超簡単だけど途中で馬鹿でかい数になった時死ぬ。
でもどう解くのかわからない。
S が非常に大きい数の場合には to_i する前に MOD で消せるものは消していい気がするが、
しかしその後文字を削られる可能性があるので、出力する時のアルゴリズムをなんとかしたい。

モジュラー算術という技法があるらしい。
たとえば MOD = 30, S = 1000 にしてみて考えやすくしてみよう。

20000 % 30
= (200 * 100) % 30
= ((200 % 30) * (100 % 30)) % 30
= (20 * 10) % 30
= 20

という感じ。これは面白い方法ではあるが、小さい積に分解するのがむずいな。
bigdecimal 使ったら早くなるかなと思ったけどそんなことはなかった。

積に分解するにはどうしたらいいんだろう。
9982443531 こういうのがあったとしても分けられないよなぁ。
ん。いやまてよ、これ同じ文字の並びだったら即座に消し去れるのではないか。

たとえば MOD = 30, S = 301000 とかの巨大数であったとしても

S % MOD = (300000 + 1000) % 30
= (0 + 1000) % 30
にはもっていける。

前方一致で削れるのは削れるんではないかという考え方。

同じように

MOD = 30, S = 53817489 とかのでっかい数

S % MOD = (53810000 + 7489) % 30 = 9

((5381 % 30) * (10000 % 30) % 30) + 7489 % 30) % 30 = 9

こんな感じなのでいけそうな気がしてきた。
9桁で分解してみるか。
最悪5万桁になるのか、それは計算できない気がしてきた。
("1" * 50000).to_i % MOD こういうのは高速だが 1000 回が限界

("1" * 10000000).to_i % MOD こういうのは計算終わらない。
* アプローチ変えよう

MOD = 998244353 の倍数を事前に計算しといて前方一致したのを消していくとか。
しかしどこまで事前計算しておけばいいんださっぱりわからないぞ。
そして、前方一致しない確率の方が遥かに高いからやっぱ無理そう。

なんかいい方法ないかな。

大きな S を小さくする S="25482529518913" みたいな感じ。0 は含まれてない。
文字列であるうちに何かをしてやればいいとおもうんだけど。
下の桁から落としていくとか？　いっしょか。

25482529510000 + 8913

計算の再利用みたいなのはいい発想な気がしてきた。

いまの mod を常にもっといて、

落ちた時、増えた時は補正するとか。

文字を落とすという行為はどういう意味があるんだろう。
MOD = 30 について

S = 1234
Ans = 4

S = 234
Ans = 24

S = 34
Ans = 4

文字を足すという行為

S = 341
Ans = 11

6万なら2重ループでもまあ解けないことはない気がする
* 模範解答

大きな s % MOD の計算方法は下のような感じ。

#+begin_src ruby
def solve(s, mod)
  ans = 0

  s.digits.reverse_each do |c|
    ans = (ans * 10 + c) % mod
  end

  ans
end
#+end_src

ruby だとなんぼでも大きな数を持てるので、これが必要になる機会は少ない。
でも今回の問題では、ちょっとずつ剰余を計算しておくということに意味があったらしい。
クエリ1 なら末尾に文字を追加するので、上の計算のループ一回の計算で済む
クエリ2 は文字が落ちるので難しいけど、逆算できるっぽい。

S = abcdefg で S % MOD = ans とする。
ここで a が落ちるなら増えてた数を落とす必要がある。下記の考察をすればよかった。
ans = abcdefg % MOD としたときに、これは下のように分解できる

ans = (a * 10^|bcdefg| + bcdefg) % MOD
ans = (a * 10^|bcdefg|) % MOD + bcdefg % MOD

これを変形すると下のようになる。

bcdefg % MOD = ans - (a * 10^|bcdefg|) % MOD

bcdefg % MOD が出したい答えだからプログラム的には下記になる。

ans = ans - (a * 10^|bcdefg|) % MOD

ちなみにライブラリもある。

https://github.com/universato/ac-library-rb/blob/main/lib/modint.rb
