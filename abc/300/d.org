* 考察

N.times do |n|
  n = 素因数分解
end

みたいなことをしてたら、ものすごいコストになって絶対終わらない。N = 10^12 なので。
log n の解法があるんだろうなぁ。

素数で探索すればいいんじゃね。

N = a^2 * b * c^2
N < c^5
N の 5乗根 < c となる。

より大きいってなるとわけわからんな。cの上限を知りたいんだが。

* 模範解答
** a の上限

N = a^2 * b * c^2

N = a^5

a < 252

素数54個

a < N^(1/5)

** b の上限

N = a^2 * b * c^2

N = 4 * b^3

b < 6300

a < N^(1/3)

** c の上限

N = 12 * c^2

c < 288675

* 効率よく計算するには
** 全探索すると
25112 から 3 つ選ぶコンビネーションになるけど、その数は膨大でとても計算はできない。

** 計算するまでもなく自明なものがある
たとえば最小の組み合わせ
a = 2
b = 3
c = 5
というのがある。
これは N = 10**12 のときは計算するまでもなく条件をみたしている。

** a,b を固定する

a = 2
b = 3

で固定して c は素数リストから2分探索して越えない最大値を選ぶ。
すると c の発見は log(p) で見つかる。

** a,b の選び方

a < b という条件があるから。
pC2 となりかなり渋い計算量になる。


** a だけ固定する

a = 252 とかで固定すると b の選び方はかなり絞られるはず。
a < b という条件があるうえに
N = a^2 * b * c^2 というのがあるから

K = b * c^2 を満たすように動かない
K は結構小さくなっているし、b は 252 より大きい数でないとダメ。

* 大きい組み合わせだけ探索してそれより小さいのは全部可能判定を与える

たとえば

a = 2
b = 5
c = 7

が最大の組み合わせだとしたら b=3 c=3,5 とかもいけるぞ、みたいな感じ。
うーんでも組み合わせだから難しいんだよなぁ。

c を固定するか？
というか b だけ次数が小さいから b を固定した方がよかったりするのかな。

K = ac

これだと2上を外せるからやさしい。

K = Math.sqrt(N/b)

b > 2 な素数。

たとえば 577350 より小さくなるように
素数の掛け算 ab を作り、その種類はいくつあるか？
