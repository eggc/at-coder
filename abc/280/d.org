* 問題

巨大な整数 K が与えられる。
任意の整数 A を使って K * A = N! を満たす最小の N を求めよ。

* うまくいかなかった解法

A = 1, 2, ... と全探索することはできる。
このとき、N! として受け入れる値をつど計算する。

| A     | 1 |  2 |  3 | ... |
|-------+---+----+----+-----|
| K * A | K | 2K | 3K | ... |

1! = 1
2! = 1 * 2
3! = 1 * 2 * 3
4! = ...

最悪の場合は K が大きな数で素数のとき。

K! = 1 * 2 * ... * K

まで計算しないといけないうえに K * A = K! を満たす A は (K-1)! だから O(K-1!) となり到底計算できない。
** 場合わけ

K が素数の時は N=K というのはわかっている。
K が素数ではない場合を考えてみよう。

K は素因数分解することができる。

K = f1 * f2 * f3 ...

K * A = N! だから

f1 * f2 * f3 * ... * A = N!

を満たす N を求めるのが目的にすり替えられる。

** さらに場合わけ

すべての i j について fi と fj が等しくないなら N は最大の素因数 fmax で確定する。

fi と fj が等しいものが混ざっている場合は、N! がそれらの素因数をカバーできるかどうかで判定する。

N! が素因数 f1, f2, ... をカバーしているということは

1! = 1
2! = 1 * 2
3! = 1 * 2 * 3
4! = 1 * 2^3 * 3
5! = 1 * 2^3 * 3 * 5
6! = 1 * 2^4 * 3^2 * 5

のように階乗を素因数分解してみないとわからない。

N! = 1 * 2 * 3 * 4 * 5 * ... * N なので少なくとも1個ずつはカバーしているはずだが。

ここから素数を追い出したらどうなるだろう。

N!/subset = 4 * 6 * 8 * 9 * 10 ...

この残り数が素因数をカバーしているか調べれば良いのかもしれない…。
もしカバーできていない場合はよりカバーできるより大きな数を N にとる必要がある。
逆か。

「素因数分解をほどほどでやめる」

という発想がいるのかもしれない。

** 倍数の構築

#+begin_src ruby
answer = fmax
permutation = answer!

loop do
  value = K * i

  if permutation == value
    exit
  elsif permutation < value
    i += 1
  else
    permutation *= next_permutation
  end
end
#+end_src

** たとえば K = 2^20 だったとするとどうなる

N = 2! と仮定してから計算を進めていくと
最悪でも N = 20! くらいで停止するから 20 ステップで終わる。

** たとえば K = 2 * L (L は巨大な素数)だったとすると

N = L! と仮定してから計算を進めていくと
すぐさま L! で計算が終わるはずだから 1 ステップで終わる。

と思ったら階乗の計算が遅すぎてダメだった。
階乗を計算せずに答えに到達する方法はないか。
うーん、階乗の素因数分解みたいなことができればいいのかな。

** 「ある数 X が階乗の倍数かどうかを調べる」という方法はないか

X を素因数分解して

1,2,3,4,5,6,7,8,9,... の箱を埋めることができればそれは階乗の倍数であると言える。
だからこのアルゴリズムを考えてみよう。

* 模範解答1

- 1! % K
- 2! % K
- ...
- K! % K = 0

まで試せばいつか答えにたどりつく。
そして二分探索をすれば log(K) 回の判定でよいはず。
K! は桁数がすさまじいことになるので計算できない。

N! が素数 p で何回割り切れるか考えよう。これを f(N, P) とおく。

たとえば f(10, 2) は

    10! = 1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10
f(N, P) = 0 + 1 + 0 + 2 + 0 + 1 + 0 + 3 + 0 + 1
        = 8
        = (10/2).floor + f(5, 2)

一般化すると下のことが言えるらしい

f(N, P) = (N/P).floor + f((N/P).floor, P)


* 模範解答2
** 問題を読み替える

正の整数 K を素因数分解した結果を K= p1^a1 * p2^a2 * p3^a3 ... * pm^am とおく。
正の整数 X が K の倍数であるということは

- X は p1^a1 で割り切れる
- X は p2^a2 で割り切れる
- X は p3^a3 で割り切れる
...
- X は pm^am で割り切れる

ということ。これは「任意の 1 ≦ i ≦ m について X が pi^ai の倍数である」と同値。

ここで X = N! と置き換えてみると

- N! は p1^a1 で割り切れる
- N! は p2^a2 で割り切れる
- N! は p3^a3 で割り切れる
...
- N! は pm^am で割り切れる

といえる。そして N' < N であるとき N! は N'! で割り切れる。

- p1^a1 を割り切れる最小の階乗を N1!
- p2^a2 を割り切れる最小の階乗を N2!
- p3^a3 を割り切れる最小の階乗を N3!
- ...
- pm^am を割り切れる最小の階乗を Nm!

としたときに最大となる Ni が求める答え


** Ni を計算するには

正の整数 X があるとき、ある素数 p ある整数 i, j について

- X = i * p^a である
- X = j * p^(a+1) ではない

を満たす 0 < a を fp(X) として定義する。
fpi((Ni-1)!) < ai < fpi(Ni!) を求めたい。

例1

#+begin_quote
X=2 p=2 とすると

2 = i * 2^1  # i = 1 で成立
2 = j * 2^2  # j は成立不可能

なので f2(2) = 2
#+end_quote

例2

#+begin_quote
X=10 p=2 とすると

10 = i * 2^1  # i = 5 で成立
10 = j * 2^2  # j は成立不可能

なので f2(10) = 2
#+end_quote

という感じ。

fp(N'!) = fp((N'-1)!) + fp(N') であることから fpi(Ni) > 0 がいえる。
つまり Ni は pi の倍数である必要があり Ni < aipi である。

N1...Nm は O(logK) で計算できる。
