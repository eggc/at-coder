https://atcoder.jp/contests/abc263/tasks/abc263_d

* 問題文
長さ N の整数列 A=(A1, A2, ... AN) が与えられます。
あなたは以下の連続する操作をちょうど一度だけ行います。

- 整数 x (0≤x≤N) を選ぶ。x として 0 を選んだ場合何もしない。 x として 1 以上の整数を選んだ場合、A1, A2, ... Ax をそれぞれ L で置き換える。
- 整数 y (0≤y≤N) を選ぶ。y として 0 を選んだ場合何もしない。 y として 1 以上の整数を選んだ場合、AN, AN-1, ... AN-y+1 をそれぞれ R で置き換える。

操作後の A の要素の総和として考えられる最小値を求めてください。

* 制約
- 1≤N≤2×10^5
- −10^9 ≤L,R≤10^9
- −10^9 ≤Ai ≤10^9

入力は全て整数

* 案

いいかえると、操作をしたあとの数列の総和がなるべく小さくなるように

- 先頭から x 個を数値 L に置き換えても良い
- 末尾から y 個を数値 R に置き換えても良い

そうして最小値をつくってみせよと言っている。

数列はまあまあ長い。
先頭から部分和をとった配列を作ってみたらよさそうだ。

list-of-sum = Sum(A1), Sum(A1,A2), Sum(A1,A2,A3)

これと

list-of-L = L, 2L 3L, 4L, ... を比較して
置き換えた場合の利得 PROS = list-of-sum - list-of-L が最大になるようにする
同じようにして R も決定すれば良いのではなかろうか。

L = 4
R = 3
A = 5 5 0 6 3

list-of-sum = 5, 10, 10, 16, 19
list-of-L   = 4, 8,  12, 16, 20

この中で list-of-sum - list-of-L が最大になるのは 2 番目。
なので2番目まで L で置き換える。
適用して、反転して同じアルゴリズムを使う

R = 3
A = 3 6 0 4 4

list-of-sum = 3, 9, 9, 13, 17
list-of-R   = 3, 6, 9, 12, 15

差が最大になるのは 2番目のとき。だからこれを使ってみる。
A = 3 3 0 4 4 となり合計は 14 が答えとなる。

=> 不正解

* 反例をみつけよう

L の利得と R の利得で戦わせてないけど、それでいいのか？　という疑問はある。

L の置換領域と R の置換領域がもしオーバーラップしてる場合は L と R のうち小さい方が使われるべき
→自然とそうなる気がする。→うそでした。

9 3 3
5 0 0 0 0 0 10000 6 3

L と R の利得の計算は両方やって、小さい方を選択するようにしたらいい。
これも実装してみたがそれでも不正解だった。

* 別の反例を探してみる

あーそうか、 L と R 逆にして良いとは言ってないから
逆にできないパターンもあるんだ。

L=2
R=3
A=500 0 0 0 0 0 10000 6 3

間違ったアルゴリズムだと
A=2 2 2 2 2 2 2 2 2

正解は
A=2 0 0 0 0 0 3 3 3

Rを先に計算すると間違っていて
A=3 3 3 3 3 3 3 3 3

で正解に辿り着けない L からやっても R からやってもダメ。

このことから、単に逆にすれば良いというものではないことがわかる。
オーバーラップしてる場合の解はもっと慎重にやらないとだめだ。
もう一工夫したらいけそうな気もするが答え見てみるか。

正解の作戦は順番に | をいれて、境界を決める

L=2
R=3
A= L|R 500 0 0 0 0 0 10000 6 3

この場合は A=3 3 3 3 3 3 3 3 3

L=2
R=3
A= 500 0 L|R 0 0 0 0 10000 6 3

この場合は A=2 0 0 0 0 0 3 3 3

境界 | を全部の位置で試してみて、答えを得るというのが模範解答でした


* 模範解答

（操作をオーバーラップさせる必要がないから、境界 k というのを定めるのか）

A の部分数列 A' = (A1, A2, ... Ak) を考える。
A' に対して、x ≦ k をみたす x を選んで操作Lを行った時の A' の総和の最小値を f(k) とおく。

（どのような x が良いかは不明なまま）

同じように A'' = (AN-k+1 ... AN) を考える。

（A の後ろからN-k個をとってできる数列）

A'' に対して y ≦ k をみたす y を選んで操作Rを行った時の A'' の総和の最小値を g(k) とおく。

f(0), f(1), ... f(N), g(0), g(1), ... g(N) が列挙できれば、答えは min(f(i) + g(N-i)) で求められる。
ペアを作る必要があるというわけ。

f(k) の求め方を考えると

# 境界値 k = 0 のときは左領域には一個も要素がないので
f(0) = 0

# f(k+1) ですべての要素を置き換えない場合すなわち x < k + 1 のとき
# もはやできる操作は何もないのでただ加算するのみとなる
f(k+1) = f(k) + A(k+1)

# f(k+1) ですべての要素を置き換える場合すなわち x = k + 1 のとき
# 次の要素を置き換えると k+1 個の L が出来上がる
f(k+1) = L * (k+1)

# どちらが選択されるかはわからないので両方計算して
f(k+1) = [f(k) + A(k+1), L * (k+1)].min

一方 g(1), ..., g(N) は配列を反転して境界値を N-k と置き換えれば全く同じようにして計算できる。
