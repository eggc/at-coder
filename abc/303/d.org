* 問題

    a            A
    A            a             CapsLock
<-- X --->
          <----- Y ----->
                         <------- Z -------->

最短時間で入力する方法を探そう。
入力文字列は最大で 300000。
CapsLock を押す方がいいのか、押さない方がいいのか。

* 考察

全探索は厳しい。
各文字ごとに CapsLock 押す、押さないで探索すると
2^300000 の分岐が発生する。

明らかに無駄なのは1文字ごとに capsLock を押すとかは無駄。
どうやって最適化すれば良いんだろう。

ヒントとして全てCapsLock が OFF の場合を最初に動かしてみる。
そうすると、最低実行時間はわかる。
なのでそこから、手を加えて改善できる部分を探してみる。
A が大量に登場するなら CapsLock をかけた方がよい。

なにかゲームのような物に置き換えたら動的計画法が使えるのではないか。

- セルの値は、実行時間。
- 横列は、CapsLock を押す、押さない
- 縦列は、i 番目の文字

|   | no caps | 1 caps | 2 caps |
|---+---------+--------+--------|
| 1 |       x | y      | x      |
| 2 |      2x | 2y     |        |
| 3 |      3x | 3y     |        |
| 4 |         |        |        |
| 5 |         |        |        |

使えない。なぜなら、caps は複数回押してもいいので、横が 2^300000 くらいになってしまう。

プレイヤーにできるのはそのシーケンスに対して事前に Caps のコストを払うかどうかだけ。

利得があるかどうか先読み
利得がないならそのまま
利得があるならCapsLockを押す

利得とは CapsLock false のとき、これからの ? ステップに対して・・・
(Y - X)(|A| - |a|) > Z をみたすならば、CapsLock を事前に有効にするのがよい。

ただそれが最善手とは限らない。
なぜなら、幾らかのステップをスルーしてから CapsLock をかけるほうが利得が大きいかもしれないので。
つまり、最善手取るにはシンプルな greedy algorithm ではダメそう。

入力列の中から何か特性を表す値が取れないだろうか。短調増加とかそういうやつ。
たとえば交互に出現するときはCaps をかけることに全く意味がないのでそれは相殺して u という文字に置き換えちゃうとか。
でも uA とかは caps ついてた方が有利だし前後関係含めると確実に意味がないとは言えないね・・・。

同じものが出現するということは当然あり得る。
たとえば aAaaAAAA ... aAaaAAAA みたいな感じの列が出てくることもあるでしょう。
そういうのは全く同じ方法で CapsLock を差し込めば良い・・・のだが、
それが隣り合っているのかそうじゃないかで CapsLock の差し込みの余地が変わる。

* 模範解答

下記のように定義する。

- i = ステップ数
- j = caps lock 状態 0 = false, 1 = true
- dp[i][j] = 最小時間

|   | no caps         | caps            |
|---+-----------------+-----------------|
| 1 | x               | y               |
| 2 | [2x, x+y+z].min | [2y, x+y+z].min |
|   | ...             | ...             |

という感じで表を作る。

1stepごとのボタンの押し方を X, Y, Z+X, Z+Y の４種類にするのが工夫点。

こうすることで X, Y の羅列に Z を差し込むよりも簡単に
すべての状態遷移を網羅することができる。
