* 検討

A = 0,1,2,0,1,2,2,1,1,1,2,1,2,1,2,0
S = M E X M E M X E M E M E M E X X


- i < j < k を選ぶ
- S[i] S[j] S[k] が MEX になっているなら mex(i,j,k) を加算

mex(i,j,k) は A[i] A[j] A[k] と一致しない最小の非負整数なので 0,1,2,3 のどれか

* MEX の選び方

3つの整数を選ぶやり方は (1..N).combination(3).count なので O(N^3) になる。 N = 20000 なので辛そう。

M の選び方 6000
E の選び方 6000
X の選び方 8000

こういう感じあるかもしれない。条件を満たす選び方はもう少し減る。
M と E を選べば、X の選び方は検索しなくても見つけられる。

* M (i)と E (j)が固定されている場合

(j..N).times.sum do |k|
  if S[k] == 'X'
    [A[i], A[j], A[k]].min
  end
end

こんな感じ。ループは回るし min をとってるから遅いかもしれない。
min は取らなくても

A[i], A[j], A[k] の空間は有限個しかないからあらかじめ配列つくっておいてもいいかも。

[0,0,0] = 1
[0,0,1] = 2
[0,1,0] = 2
...

って考えたら j..N のループで計算はすぐできる。

j が変化した時に起きることとしては、ループの長さが変わるだけ。
ってことは数列の部分和をとるアイデアが使えるだろう。

配列を用意して整えておけば高速に答えが出せる。

- [A[i], A[j]] = [0,0] のときの XS
- [A[i], A[j]] = [0,1] のときの XS
- [A[i], A[j]] = [0,2] のときの XS
- [A[i], A[j]] = [1,1] のときの XS
- [A[i], A[j]] = [1,2] のときの XS
- [A[i], A[j]] = [2,2] のときの XS

6回ループ回すことになるな。

* 一応解いたけど TLE なってしまった
