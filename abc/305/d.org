* 考察
区間の合計値を取る問題。
素直にやると与えられたクエリの幅に応じて配列を探索する必要がある。
O(|A| * |Q|) となる。しかし |A| は 20000 で |Q| = 20000 なので探索は4億となり絶望的。

ぱっと見 imos と関係ありそうに見えるけど、あれは重ね合わせの問題だから少し違う気がする。
累積和の方法が何かの役に立つような気がする。


端以外は、1つ飛ばして累積和の方法で計算できそう。
「配列添字 i,j に対してその区間の睡眠時間を計算せよ」という問題だとみなして考えてみる。
そうすると、
i が奇数なら Sum(i+1,j) が答え
i が偶数なら Sum(i,j) が答え

def Sum(i,j)
  A[i..j].each_slice(2).sum do |head, tail|
    tail - head
  end
end

このようにして計算できる。ループをすることは望ましくない。
なので部分和の手法を使って効率化する。

当然 i,j に当てはまらない領域が与えられることもある。
そのときは i,j でいうとどの辺にあたるのかを知る必要がある。
* 始点終点に関する考察

始点、終点を発見するのにも A の探索が必要になってしまっているが、
これは2分探索で見つけることができる。
log2(20000) は 14 くらいなので 14 * 20000 なら十分探索できるはず。

0
20 62 （ここから）
[i=192] 284
310 323
324 352
374 409
452 486
512 523
594 677   (ここまで)
[j=814] 838
946 1000
