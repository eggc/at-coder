* 問題の内容

A をマッピングしていく。
条件は
p1 = 0, 0
p2 = A1, 0
pi = ?
pN+1 = x, y

- pi は pi+1 との距離が Ai
- pi pi+1 と pi+1 pi+2 は直交する

  言い換えると x 軸移動なら y 軸移動を交互に繰り返すってこと
  移動方向は + と - のどちらに行くのかはわからないので探索する必要がある
  探索2分木ができる


* 案1

- bit 全探索みたいなことをするか
- 最大で N = 1000 なので 2^1000 の探索になってそれは辛い
- それはDFS, BFS でも一緒、効率化はできないし、解が存在しないときに 2^100 を走る

* 案2

- 探索打ち切りの手法
- 区間スケジューリングの問題と少し似ている気がしてきた
  - pi の i が奇数ののときだけ取り出してみると、その選択肢は <- -> のどちらか一方にしか動かない。
  - pi+1 では x 軸方向に一切動かない
  - pi+2 をどちらに移動させるのかを考えるときも、やはり <- -> どちらか一方にしか動かない。
- この観察からいえることは
  p1, p3, ... pN+1 の座標決定を先にやって問題ないということ。
  そして x,y 軸を入れ替えれば p2, p4, ... の座標決定もできるということ。

- 足したり引いたりして x を作れ、という問題に置き換えれる。

1 [ ] 2 [ ] 3 = x

なんかいい方法ないのかなぁ。項が500個もあるから全探索はできない。
おや Ai は 1..10 なのか。それが重要な気がする。
ソートしてカウントしておいて

|   1 |   2 |   3 | ... | 10 |
|-----+-----+-----+-----+----|
| 2個 | N個 | ... |     |    |

みたいな表を作っておくと、作りたい数が作れるかもしれない。
特に 1 は微調整するのに使える。
そこからは貪欲法でやってみればいいのかな。

- 最初全部足して current にする
- current < x なら失敗で終了
- current == x なら成功
- current > x なら
  - diff = current - x
  - bucket[i] < current - x  を満たす i を選択して引く
  - 最大で 1000 回試してダメだったら失敗
  - current == なら成功

んーだめだ違ってた、この方法では負数とかがうまく探索できない
あと最初の一手はプラスでなければならないというところも問題

6 + 4 - 5 + 8 - 5

これで 8 が作れる。貪欲法だとうまくいかない。
なぜかというとまず最初に足して

28 = 6 + 4 + 5 + 8 + 5

ここから 8*2 を引いて 12 で手詰まりとなる。
