* 案

問題は整数列を連続する3つの部分列に分解しろと言っている。
部分列はそれぞれ足し合わせた時に P, Q, R になるようにしなければならない。

整数列は 20000 個ある

整数列を5個に分解する可能性はいくつある？

** 3個の仕切りをどこに差し込むかみたいな問題

20000 ^ 3 となって 8億通りあるので、めちゃくちゃ厳しい。

けど重複があるので実は計算しなくていいのが含まれてる。

** ヒント情報を計算してみる

部分列は始点と終点が20000通りあるとしたら 20000 * 20000 で 40万になるけど一応計算できるかもしれない

たとえば
A = 1 3 2 2 2 3 1 4 3 2
P = 5
Q = 7
R = 5

これを解くときに

0-0
0-1
0-2
0-3
0-4
0-5
0-6
0-7
...
1-1
1-2
1-3
...
2-2
2-3
...

みたいな和を計算するのはできる。これをヒント情報としておく。
そして、答えを探索するときには
ヒント情報から探す

** 素直に解いてみる

0 から探索して P が作れないことが確定したら 1から探索して・・・これは最大 20000 * 20000 でこれを 3回やればいいから 120万回でとける。
これか。なーんだ。だめだった。

Yes or No だから何かの条件を満たしてたら解を出さずとも解の存在を知ることができると言うことなんだと思う。

* 模範解答

S0 = 0
S1 = A0
S2 = A0 + A1
S3 = A0 + A1 + A2
S4 = A0 + A1 + A2 + A3
...

を計算しておく。すると SR - SL で区間和をすぐ計算できる。
たとえば

S4 - S2 = (A0 + A1 + A2 + A3) - (A0 + A1)

なので S4 - S2 = A2 + A3 となる。ruby で言うと S[2..4] = A2 + A3 ということ。

ここで x を固定してループを回して条件を満たす y を探す

条件とは S[x..y] = P を満たすものである。

これは変形して S[y] - S[x] = P と書くことができるから
S[y] = P + S[x] を満たす y をみつければいい。

S.find { |k| k == P + S[x] }

これだと遅いのでバイナリサーチを使う

S.binsearch_index { |k| P + S[x] - k }
