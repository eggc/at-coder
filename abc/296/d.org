X = a * b
1 <= a <= N
1 <= b <= N
M <= X

* 全探索する場合は

1,1 ... 1,N
2,1 ... 2,N
    ... N,N

の O(N^2) を探索することになる。
そしてえらばれた a * b = X のうち M <= X を満たす最小のものが答え。

例えば M = 1 だったとするとそれは最小値を探すのと同じ。1*1 が答えになる。
計算量は非常に少ない。

M = 2 のときも 1*2 が答えになる。それが作れないなら答えは出せない。
M = 3 のときも 1*3 が答え。それが作れないなら答えはない。
M = 4 のときは 2*2 が答え。それが作れないなら答えはない。
M = 5 のときは 1*5 が答え。
M = 6 のときは 2*3 が答え。
M = 7 のときは 1*7 が答え。

M が素数の時は 1*M が答えとなる。それ以外は答えがない。
M が素数ではないときは素因数分解して m1,m2,...mk をなるべく均等に分配した a*b が答えになる。
例えば素因数分解した結果が 2,2,2,13 の場合は 8*13 に分けるがこれをどう見つけるか。
「なるべく均等に」を全探索するとしたら 2^k の組み合わせがあり得る。

10^12 を超えない数で最も因数が多いのは 2^39 がある。これを全探索すると死ぬ。
だからある程度効率よくやる必要がある。

「なるべく均等に」を実現する良いアルゴリズムは何かあるのだろうか。

* 案：最も大きい素因数を a に入れる。次に大きい素因数を b に入れる。

以降の数を a,b の小さい方に掛け合わせる。
これの失敗例は 13,11,5,2,2,2

13 * 2 * 2 * 2 = 104
11 * 5 = 55

本当の答えは

13 * 5  = 65
11 * 2 * 2 * 2 = 88

の方がいい。こういった戦略はうまくいかない。

* 探索を軽くする

2^3 の振り分け方は 2 を a にいくつ掛け合わせるかできまる

0 なら 1-8
1 なら 2-4
2 なら 4-2
3 なら 8-1

これで4通り。2^k なら K 通りになる。
そこで下記のような素因数があるとき

13,11,5,2^3

組み合わせとしては 2 * 2 * 2 * (3) の組み合わせがある。
これなら少し探索の負荷が下がる。
2^39 も39通りの組み合わせしかないので、これなら計算可能かもしれない。
厳密にはわからないがとりあえずこの方針で進めてみようか。
掛け合わせの計算は何度も何度も同じことをする可能性があるから

* いや、問題を読み違えている。

M = 2 のとき
  N = 1 では答えがない
  N = 2 なら X=2 が答え
M = 3 のとき
  N = 2 としたら X=4 が答えになる。
  N > 2 としたら X=3 が答えになる。
  N < 2 では答えがない
M = 4 のとき
  N > 2 としたら X=4
  N < 2 では答えがない
M = 5 のとき
  N = 3 のときは X = 2*3 = 6 が答え。
  N = 4 のときは X = 2*3 = 6 が答え。
  N > 4 のときは X = 5 が答え。
  N < 3 のときは答えがない。

こんな感じなので単純な議論では終わらない。
N以下の2個の数で作れる数には何があるんだろう。

|     | a=1 | a=2 | a=3 |    |
| b=1 |   1 |   2 |   3 |  4 |
| b=2 |   2 |   4 |   6 |  8 |
| b=3 |   3 |   6 |   9 | 12 |
|     |     |     |     |    |

こんな感じの 9x9 の表を拡張していく感じ。
合成数を見つけるのは素数リストがあれば案外簡単かもしれない。

primes = 素数リスト
i = primes.find_index {|x| x >= M }
で M を発見できそう

* X = ab を満たしているかどうかの判定は ab <=N*2 でいい気がする。

エラトステネスの古いはO(N log N)だからダメっぽい・・・。

* うまくいかない

問題を読み替える

合成数 X は作れるか？

M <= X <= N^2


- M が合成数なら M でOK
- M が素数なら M+1 でOK ただし、 M<N なら M でOK

  しかし即落ちした。。。

落ちるケース見つけた
32 1020
