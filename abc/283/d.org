* 問題

- 文字セットは [a-z()]
- 良い文字列の検証方法
  - a-z を削除
  - 連続する () を削除
- プログラム
  a. S[i] が a-z なら box に S[i] を入れる。ただしすでに box.include?(S[i]) ならプログラムは失敗して停止。
  b. S[i] が ( なら何もしない
  c. S[i] が ) なら j < i の j に対して S[j..i] が良い文字列となる最大の整数 j を取る。そして box から S[j..i] を取り出す。

S は最大で 30000 文字。
出力は Yes/No だけ。

* 案

一番素直な方法はシミュレーションすること。
S[i] を順番にながめてプログラムの通りに判定する。
box を set で実装するとして手順 c がよくわからない。
カッコの対応関係を調べていけばいいのかな。

カッコはスタックで実現できる。
スタックする時にカッコの座標も一緒に覚えておく。
そうすると最長の良い文字列を探す時には、カッコの対応が壊れない範囲を外側から探索すれば良い。

カッコの状態マップと、最後にみたカッコと対応するカッコの座標を覚えとけばいいのか。
そうすると c を定数時間でやれる気がする

a. log(n)
b. 1
c. 1

* j を見つける方法

pairs を探索する
x(a(b(c(d)e)f)g)h こんな感じのペア構成で、いま最後のカッコを探索しているとする。
その場合は pairs を遡っていき close が出たら +、そうでないなら - する。
そうして値が 0 になるときにその周辺が j になる。
この例で言うと a のあるところが j になる。

この探索のコストはデータ次第だけど最大で3万くらいになる可能性はある。
なのであらかじめ、閉じカッコと対応するカッコを記憶するようにしたらいいかもしれない。

opens = ...
closes = ...

みたいな感じにしとけば簡単にもとまる。これを使えば探索範囲はかなり狭くできる。

if current_close_count == 1
  0
else
  opens[current_close_count - 1] + 1
end

と思ったけどかっこの対応関係って、そんなに簡単なものなのかな？

()()()

たとえばこんな感じで並んでいたとしたら

opens = 0, 2, 4
closes = 1, 3, 5

で対応は取れるけど

((()))

これだったら

opens = 0,1,2
closes = 3,4,5

だから対応が取れてない。だめだ。
単純な配列では対応とれないんだ。

* 2重ループを解くことはできないか

ここだけ解決できれば勝てそう
j は事前にわかってるからある程度楽できそうな気はする

* 模範解答をみた後再チャレンジ

i = 1, 2, ..., |s| に対して、すべて box_histories に履歴を取る。

- [a-z] なら box_histories を更新
- ( なら、何もしない
- ) なら対応するカッコの状態まで box_histories[i] = box_histories[j] とする

j を発見したら box_histories を使ってロールバックする。
j を発見する方法は対応するカッコの座標がわかれば良い
