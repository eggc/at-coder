* 再帰関数 f(N) を求めるという問題。

f(0) = 1
f(k) = f(k/2) + f(k/3)

で定義する。
これはメモ化すればいいだけなんじゃないか
で実行してみたら N が非常に巨大な値だったので計算不可能だった。
N = 10^18

1000000000000000000

あーこれもしかして配列でやるとまるごと byte 確保しちゃってるから無理なのかも。
hash で作り変えてみようか。いけた。

下から積み上げていくほうがいいな。と思ったら下から積み上げだと
メモ化使うと全部やるから遅い O(N logN) ？
穴開きで計算するほうが良いのはよさそう。
そのうえで、同じ計算はしないようにしたい。ループでこれが書けるのか…？

* これの計算量はいくつなんだろう

再帰的計算なのでよくわからないけど一個の f(k) がツリーを構成するとして
f(k) は子供に f(k/2), f(k/3) ノードを持つとしてその子孫を数え上げれば計算量になる。
そのようにして作られたツリーは complete combinary tree となる。
根の深さは k を 2 で割り続けて 0 になるまでの数になるので log k
大まかに考えると  O(2^(log k)) 程度の計算量になる。
k が小さいときはさほど辛くないが = 10^18 のときは

Math.log2(10**18) = 59.794705707972525

となり 2^60 の計算が必要になる。これはまともに取り組んでいると終わらない。
メモ化した場合は同じノードが消滅する。

模範解答ではメモ化をした場合の計算量が書いてある。
これによると

メモ化した場合の引数の種類は N / 2^x * 3^y で表される非負整数 x, y となるらしい。
そのような x,y の種類は log N 程度となり、結果 O(log N) で解けるのだという。
