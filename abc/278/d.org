* 最初の一歩
これもシミュレーションする問題
クエリは20000個。配列の要素も20000個。
数字は最大で 10^9 = 1億。

効率的にシミュレーションしないといけない。

- 1 は全ての要素に代入すると言ってるけど、実際に代入したら大変なので、代入したということだけ覚えておけばいい。
- 2 は加算するだけなのでコストは低い。やっていいが、1 が先行してる場合ちょっと困るのでクエリのまま覚えとくしかないかも。
- 3 は出力する。

N^2 でやれるんならそれでも良くないかって思ったけど厳しいのかな。
まずクエリ一周して 3 のクエリを探すようにするか。
で、3のクエリで指定されてる番地以外は関係ないというのをメモしておく。

一回ループ回して、各要素の生存期間をハッシュで覚えとこう。

で、やってみたが TLE になってしまった。

* TLE をどう改善するか

代入するときに全部やらなくても、表示する時まで遅延してもいい。
出力命令が出るまで計算はしない・・・？

最初のループで、意味のないクエリは捨てるようにするか。

意味のないクエリとは

- 3 が出現して、次の 3 が出現するまでに
- 1 が2回以上出現するなら最後の 1 以前は不要クエリ

不要クエリを取り除くようにしてみたがそれでも足りないらしい・・・。

* 二重ループをやめるにはどうしたらいいんだろう。
必要ないものをさらに削るというのが求められることなんだろうけど。
ttl を洗練させるとしたら。スモールシミュレーションみたいなのがテーマなのかな。
配列クリアされた時の数字を clear_value にいれる（操作はしない）
add_values という hash へ加算数を記憶する。
そんで出力する。

あーこれが最適解なんだ。オーダーの考え方大事だなぁ。
先人はかしこいなぁ・・・。
