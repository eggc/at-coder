* 全探索

S を最大にするには ? = 1 にすればいい。
そこから順番にビット全探索で減らしていくことはできる。
? の数を |?| と書くとしたら O(2^|?|)の探索が必要。
? は最大で60個になるのでとても探索できない。

探索範囲は N 以下で良いという制限はある。
しかも最大を探せばいいことになっているから、まずは N を２進数で表現するとヒントになるだろう。

たとえば

S = ?0?
N = 2

のときは

T = 10

なので T = 010〜000 を探索すればいい
そして S = ?0? については先頭ビットが 0 で固定になるので下1桁のビットだけ調べればよくなる。

S = 101
N = 4

のときは

T = 100〜000 を探索するのだが
S = ?0? については
S = 100 が見つかって終了。

S = 101
N = 10

のときは

T = 1010
S = 0101

を見つけて終了

* T 以下の最大の S を発見する方法

ビットを決めていけばいい
そのためにはまず桁合わせが必要
60桁で固定するとわかりやすくなるかも。

* いやしかし先頭一致させてもだめだな

S = ?1?
T = 101

このケースがうまく解決できない。
011〜010 の探索であることを見抜けるアルゴリズムにしないといけない。
111〜010 の探索ではあるんだけど、そこを絞れるというのを教えてあげないといけない。

T からカウントダウンしていくのはいいと思うんだけど
S の条件を満たしているかをチェックしないといけない

* 場合わけしてみる

- Smax <= N なら S に全部 1 を立てた Smax が答え。
- Smax > N なら N が答えかもしれないし、S を程よく小さくした値が答えかもしれない。
- Smin > N なら -1 が答え。

なのでより複雑な S > T のケースが解けたらよい。

たとえば S = 1???? だったら話は簡単で連続しているので1ずつ探索すればすぐわかる。
そうじゃなくて S = 1?1?1 みたいなのが困る。値が連続してないので小さいか大きいかよくわからない。

再帰でとけるんじゃないか

? を 1 or 0 で仮定して比較すれば一応解ける
全探索しないで枝刈りするには探索範囲を共有して
メモ化して最大値以下になることがわかった時点で打ち切ればいい。
