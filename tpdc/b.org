* 自分で考えてみる

A = [a1, a2, ... ]
B = [b1, b2, ... _]_

すぬけ、すめけが交互に高い方のアイテムを取る。
最善手を選び続けた場合どうなるのか？
最善手が何かを見つけるのがそもそも難しい。

なので全探索せざるを得ない。
全探索した上で一番点数が高いものが答え。

素直に全探索すると山 A か B のどちらか一方から
アイテムを取り出すのを選択できるから O(2^(A+B)) となる。
AとB の山が消えた時点で選択肢がなくなるとはいえ
A, B はそれぞれ最大1000なのでこれを全探索するのは不可能。

最終点数を解の空間としてみたらどうだろうか。
1000 * 1000 が解の上限となる。
10^6なら一応探索可能に見える。

しかしDPのテーブルを組み立てるときどうしたらよいのかよくわからない。
テーブルの行列をどうやって構成するか。

| 手番 \ 得点 | 1 | 2 | 3 | ... | 10^6 |
|-------------+---+---+---+-----+------|
|           1 | o | x | x |     |      |
|           2 |   |   |   |     |      |
|           3 |   |   |   |     |      |
|           4 |   |   |   |     |      |

こんな感じでどうだろう。しかし各手番でとれるアイテムがどっちなのか予想困難だからダメそう。
たとえば a1, a3, a5, ... という順番でアイテムを取ることはできるが両者が最善を尽くした場合必ずしもそうならない。

「両者が最善を尽くす」という前提が結構難しい。

* 模範解答

DP[i][j] = A が残りi個、B が残りj個のときの、自分の点数 - 相手の点数とする。

| Aの残り数 \ Bの残り数 |   0 |   1 | 2 | ... | M |
|-----------------------+-----+-----+---+-----+---|
|                     0 |   0 | ... |   |     |   |
|                     1 | ... |     |   |     |   |
|                     2 |     |     |   |     |   |
|                   ... |     |     |   |     |   |
|                     N |     |     |   |     |   |

これを出したあと 0-0 から 0-1 と 1-0 を調べて ... と計算していけば DP[N][M] に到達する。

DP[N][M] = 自分が選んだアイテムの総和 - 相手が選んだアイテムの総和

これに全てのアイテムの総和を足し込めば

DP[N][M] + A.sum + B.sum = 自分が選んだアイテムの総和 * 2

となるから右辺左辺を入れ替えて2で割れば欲しい値になる

自分が選んだアイテムの総和 = (DP[N][M] + A.sum + B.sum) / 2

** DP[i][j] を計算する

B 山が枯れているとき

DP[0][0] = 0
DP[1][0] = A[N-1]
DP[2][0] = A[N-2] - A[N-1]
DP[3][0] = A[N-3] - A[N-2] + A[N-1]          = A[N-3] - DP[2][0]
DP[4][0] = A[N-4] - A[N-3] + A[N-2] - A[N-1] = A[N-4] - DP[3][0]
DP[i][0] = A[N-i] - DP[i][0]

同じように A 山が枯れているとき

DP[0][0] = 0
DP[0][1] = B[M-1]
DP[0][2] = B[M-2] - B[M-1]
DP[0][3] = B[M-3] - B[M-2] + B[M-1]          = B[M-3] - DP[0][2]
DP[0][4] = B[M-4] - B[M-3] + B[M-2] - B[M-1] = B[M-4] - DP[0][3]
DP[0][j] = B[M-j] - DP[0][j]

A山とB山が枯れてないときは

DP[1][1] = [A[N-1] - DP[0][1], B[M-1] - DP[1][0]].max
DP[2][1] = [A[N-2] - DP[1][1], B[M-2] - DP[2][0]].max

という感じなので

DP[i][j] = [A[N-i] - DP[i-1][j], B[N-i] - DP[i][j-1]].max
