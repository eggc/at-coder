* ABC 277

- C を解くのに50分もかかった上に5回もミスしていた。
  - 無向グラフなのに、一方行の辺しかデータで表現できてなくてなかなか成功しなかった。
  - 原因がわからなくて、再帰メソッドをループで書き直したりという無駄なことをしていた。
- D は翌日答えを見て解いた
  - これは問題をしっかり読んで、解法みつけてから実装しないとダメそう。
  - あまり覚えてない。

* ABC 278

- C はすぐ解けている。
- D は TLE で 3 回落として、計算量改善してクリア
  - あまり覚えてないが計算量考えれてなかったのが問題かな

* ABC 279

- C は 15分ほどで解けているが 5 回も失敗している。
  - これは自分で落ちるケースを見つけられてないのが痛い。
  - 「並べ替えて同じものが作れる」ということはユニークであることが条件ではなかった。
  - 「ソートして同じものになること」を調べればよかった。
- D は解けなかった。
  - 数学的検討はまあまあうまくいっていた。
  - ただ微分計算どうやるんだっけみたいなところで時間がかかった。
  - 計算精度も実は気にしなくていいのに時間を割いて調べてしまった。

* ABC 280

- C は12分ほどで解いている
- D は解けなかった
  - 素因数分解ライブラリと階乗の性質「ルジャンドルの定理」を利用している。
  - 模範解答見て答えた。
  - これは今見ても解ける気がしない…数学の力が問われる

* ABC 282

- C は13分で解いた
- D は3回アタックして解けなかった
  - これはかなり惜しい所まで行った
  - ただ「2部グラフ」という言葉を理解してなかったので求めるべきものを間違っていた。
  - 部分的な情報だけで、グラフの数を検討する方法に気づかないといけなかった。

* ABC 283

- C は19分で解いた
- D は2回アタックして解けなかった
  - 問題文が長い。微妙に問題をとりちがえていたのが致命傷だった。
  - 例は参考になるけど、それだけだと誤解がある。問題文をしっかり読もう。
  - カッコの対応を取るには「スタック」を使うのは知ってたけど実装したのは初めてでそれに戸惑った。

* ABC 284

- C は26分で解いた
  - 入力の受け取りをミスっていた
  - グラフの色塗りの実装がまだ甘い
- D は5回アタックして解けなかった
  - 計算量を抑えるところの発想はよかった
  - 解の性質を正しく見抜けなかったところが敗因
  - 比較的複雑なアイデアと、シンプルなアイデアを組み合わせるというのができてない
  - これも一応数学の問題ではあった
  - 素数ライブラリは大いに役立った
    - 最初自分の実装を持ってこようとしていたけど ruby にはエラトステネスのふるいはビルトインされてる

* ABC 285

- B を解くまでに50分もかかった
  - 問題文が長くて意味がわからなかった。
  - 図を書いてもわけがわからなかった。
  - 例題でなんとなくは伝わるものの腑に落ちなくて悩んだ。
  - 最終的には、問題の意味を理解するのを諦めて自分なりに解釈して解いた。
  - もう一回眺めてみる。
    - もう問題の意味はわかっているので綺麗に解けた。
    - ただ、ループを while で組み立てたほうが楽だというのに気づくまでに10分くらいかかった。
    - インデックス残したいときは変数外で初期化して while 使うほうが良い。
- C は15分で解けた
- D に使えた時間は40で、ぎりぎり解けそうだったが間に合わなかった。終了4分後に解けた。
  - 有効グラフの閉路を求めるという問題に置き換えれることにすぐ気づいたのはよかった。
  - その解法をコードにするまでにもたついたのはもっと早くできそう。

* ABC286

- C は計算量 O(N^2) には早い段階で気づいていたのに最悪値で 5000^2 = 2500万ステップだと辛そうだなと誤解してしまった。
  実際にはそのステップ数で十分実行可能になっていたようだ。
  これをしっかり覚えておいて 2500万ステップくらいは許容範囲だと判断できるようになろう。
- D は動的計画法のコードが組めただけでも成長したとは思う。ただ想定解には及ばなかった。
  - 私の解法だと O(XNB) で計算していたが 3300ms 程度で TLE になってしまった。
    最悪値では 10000 * 50 * 50 = 2500万ステップくらい。
    その後の検討で、テーブルに false を入れるより、代入しないで nil のままにしたら 2900ms で AC した。
    なお Hash でも試してみたが Hash ではほぼ改善はみられなかった。
  - 想定解の方も真似してコード実装した。この実装では、動的計画法のテーブルを圧縮されメモリが O(XN) になる。
    計算量的には O(XNB) のままだと思うが、実行時間は 1400ms 上記の解の約半分になっている。
  - がんばろう…。

* ABC287

計算量を意識してたので LTE は出さずに解けた。

- A 3分
- B 3分
- C 32分
  - 問題の理解に時間がかかった。
  - グラフの入力を受け取るのがちゃんとできてなくて数分ロス。
  - 最初に、明らかに条件を満たしてない入力を失敗させるというのは入れた方がよかった。
- D 29分→WA→36分→AC
  - 計算量の検討と、アルゴリズムの発見までは滑らかに進んだ。
  - でたらめにテストケースやって再現するのを探して、原因を見つけた。
  - 最初考えてたアルゴリズムから少し変えたとき any でなく each にすべきだった。

* ABC288

かなり難しかった。グラフのアルゴリズムが見つけられず計算量を意識できなかった。

- A 2分
- B 3分
- C 37分 WA3回
  - 答えまでの確信がないままコード書き始めた
  - 前回もグラフなのを思い出して再利用したのはよかった
  - ループ実行中に要素を削除するという行為がループの実行順を破壊していることに気づくのに時間がかかった
  - 模範解答はよりスマートなものだった
  - なんかよく見かける union find っていうやつ知っといたほうがいいかもしれない
- D 30分考えてリタイア
  - とりあえず全探索の計算量を検討して間に合わないことはすぐわかった
  - それ以上の解法が見つからなくて手も足も出ない状態に陥った
  - imos 法よりも、不変量を利用するという想定解を使うほうがよさそう。
  - imos 法を使っても、最終的には不変量をみつけないと答えに行きつかないので厳しい。
- imos法
  - 導入 https://note.com/kirimin_chan/n/n7663e3bb8a05
  - 詳細 https://imoz.jp/algorithms/imos_method.html
  - 図があるのでわかりやすい。最後の方の次数の拡張は難しいので一旦無視する。
  - imos法があっても D は解ける気がしないな。


* ABC289
