残せるロボットの個数を最大にする。

カバーする範囲が大きいロボットを取り除いたほうがいい。
あるロボット X[i] を取り除いたときに起きるのは、
そのロボットがカバーしていた範囲を全部別のロボットにカバーしてもらう必要がある

* 例1

1 10
2 9

というデータが有る場合
X[0] は 10 の範囲をカバーしている
X[1] は 9 の範囲をカバーしている

X[0].include X[1] なので X[0] を取り除いたらいい。
2個しかアームがないからどっちを取り除いてもいい。

* 例2

1 4
2 1
4 1

この例だと X[0] がなくなれば X[1], X[2] のロボットが自由に動けるので X[0] を消すべき。

* 例3

1 3
2 2
9 4

この例だと X[2] が一番長いけどどれにも干渉してないから消す必要がない。
消す必要があるのは X[0] か X[1] のどちらか一方。どちらを消しても問題ない。
* 例4

1 2
2 2
3 2
9 4

この例も同じような感じだけど X[1] がなくなれば X[0], X[2] が自由に動けるので X[1] を絶対に消すべき。
こうしてわかるように、貪欲法でよさそうとは思うのだが数学的に正しいのかどうかはちょっとわからないな。

* アルゴリズム

一番干渉が多いものを探して取り除く、これを繰り返せば良さそう。
二重ループで書けるはずだ。

a b c d e f g

こういう感じでロボットが並んでいるときに、調べるべきなのは

a VS [b c d e f g]
b VS [c d e f g]
c VS [d e f g]

なぜかというと c VS a とかは a VS c で調べ終わっているから
なので2重ループで下のような感じにできるはずだ

  N.times do |i|
    N.times do |j|
      next if i <= j
      xxx
    end
  end

うまく行かなかった…。

* 模範解答

これは区間スケジューリング問題と呼ばれる問題に帰着できる。
座標とアームの長さではなく、始点終点 (Si, Ti)の列 P を考えることにする。
ロボット i を残したとき Ti 以上の数値には影響がない。

ロボットを終点 Ti でソートし P = P[0], P[1], ... とおく。
そして先頭から順に採用していくだけでよい。領域が重複するときは採用しない。
