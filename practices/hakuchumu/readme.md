# 問題文
英小文字からなる文字列 S が与えられます。
Tが空文字列である状態から始め、
以下の操作を好きな回数繰り返すことで S=T とすることができるか判定してください。

T の末尾に dream dreamer erase eraser のいずれかを追加する。

1≦ ∣S∣ ≦10^5 で S は英小文字からなる。

# ごく素直な実装を考えてみる

- T と前方一致するキーワードのリスト W をつくる
  - W から一個選び w とする
  - T の前方から w を削ってできた文字を T に置き換える
  - T が空文字列になるまで繰り返す

これは再帰呼び出しになる。S は 10^5 という結構長い文字列なのでちょっとダメかもしれないけど試してみよう。意外と良い結果になった。

| 実行時間 | メモリ   |
|----------|----------|
| 108 ms   | 36892 KB |

# 模範解答

末尾から計算していく greedy algorithm で解けるらしい。実際試してみたがメモリ上限を超えてしまった。

| 実行時間 | メモリ    |
|----------|-----------|
| 767 ms   | 882200 KB |

文字列のコピーではなくて文字列のインデックスを使うようにすればメモリを節約できるというのがあるらしい。インデックスでやる場合、慣れてなくて色々面倒だった。終了条件が -1 になるというのに注意がいる。

あと再帰呼び出しする場合は関数呼び出しの状態がスタックに積まれるので結局メモリをたくさん使ってしまう。再帰呼び出しはしないほうが良いみたい。キューで作り替えてみた。

| 実行時間 | メモリ    |
|----------|-----------|
| 596 ms   | 115372 KB |

しかし最初の実装の方が実行時間もメモリも小さい。末尾から探索するとメモリを多く消費してしまうのは、文字列がシーケンシャルなことに関係していそう。先頭を参照すると参照しただけのコストなのに末尾を参照すると文字列全部を走査しないといけないとか。

本当の模範解答では受け取った文字を反転させてから処理していた。そうすると最初の解答と同じかそれ以上に効率よくなるのかもしれない。
